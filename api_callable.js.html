<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api_callable.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api_callable.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2016, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Provides function wrappers that implement page streaming and retrying.
 */

'use strict';

var setTimeout = require('timers').setTimeout;

/**
 * @callback APICallback
 * @param {?Error} error
 * @param {?Object} response
 */

/**
 * @callback APIFunc
 * @param {Object} argument
 * @param {grpc.Metadata} metadata
 * @param {Object} options
 * @param {APICallback} callback
 */

/**
 * @callback APICall
 * @param {Object} argument
 * @param {CallOptions} callOptions
 * @param {APICallback} callback
 * @return {Promise|Stream}
 */

/**
 * PromiseCanceller manages a promise which has cancel function.
 * @param {APICallback=} callback
 *   The callback to be called when the promise is fulfilled.
 * @constructor
 * @private
 */
function PromiseCanceller(callback) {
  this.promise = new Promise(function(resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  }.bind(this));
  if (callback) {
    this.promise = this.promise.then(function(response) {
      var args = [null];
      args.push.apply(args, response);
      callback.apply(null, args);
    }, callback);
  }
  this.promise.cancel = this.cancel.bind(this);
  this.cancelFunc = null;
  this.completed = false;
}

/**
 * Cancels the ongoing promise.
 */
PromiseCanceller.prototype.cancel = function() {
  if (this.completed) {
    return;
  }
  this.completed = true;
  if (this.cancelFunc) {
    this.cancelFunc();
  } else {
    this.reject(new Error('cancelled'));
  }
};

/**
 * A callback-styled method.
 *
 * This will be used for the final parameter of API call.
 * @param {Error=} err
 *   The error when something goes wrong.
 * @param {Object=} response
 *   The response object when succeeds.
 */
PromiseCanceller.prototype.callback = function(err) {
  this.completed = true;
  if (err) {
    this.reject(err);
  } else {
    // Resolves to an array of the remaining arguments.
    this.resolve(Array.prototype.slice.call(arguments, 1));
  }
};

/**
 * Call calls the specified function. Result will be used to fulfill
 * the promise.
 *
 * @param {function(Object, APICallback=)} aFunc
 *   A function for an API call.
 * @param {Object} argument
 *   A request object.
 */
PromiseCanceller.prototype.call = function(aFunc, argument) {
  if (this.completed) {
    return;
  }
  var canceller = aFunc(argument, this.callback.bind(this));
  this.cancelFunc = canceller.cancel.bind(canceller);
};

/**
 * Updates aFunc so that it gets called with the timeout as its final arg.
 *
 * This converts a function, aFunc, into another function with updated deadline.
 *
 * @private
 *
 * @param {APIFunc} aFunc - a function to be updated.
 * @param {number} timeout - to be added to the original function as it final
 *   positional arg.
 * @param {Object} otherArgs - the additional arguments to be passed to aFunc.
 * @return {function(Object, APICallback)}
 *  the function with other arguments and the timeout.
 */
function addTimeoutArg(aFunc, timeout, otherArgs) {
  // TODO: this assumes the other arguments consist of metadata and options,
  // which is specific to gRPC calls. Remove the hidden dependency on gRPC.
  return function timeoutFunc(argument, callback) {
    var now = new Date();
    var options = otherArgs.options || {};
    options.deadline = new Date(now.getTime() + timeout);
    return aFunc(argument, otherArgs.metadata, options, callback);
  };
}

/**
 * Creates a function equivalent to aFunc, but that retries on certain
 * exceptions.
 *
 * @private
 *
 * @param {APIFunc} aFunc - A function.
 * @param {RetryOptions} retry - Configures the exceptions upon which the
 *   function eshould retry, and the parameters to the exponential backoff retry
 *   algorithm.
 * @param {Object} otherArgs - the additional arguments to be passed to aFunc.
 * @return {function(Object, APICallback)} A function that will retry.
 */
function retryable(aFunc, retry, otherArgs) {
  var delayMult = retry.backoffSettings.retryDelayMultiplier;
  var maxDelay = retry.backoffSettings.maxRetryDelayMillis;
  var timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;
  var maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;

  var delay = retry.backoffSettings.initialRetryDelayMillis;
  var timeout = retry.backoffSettings.initialRpcTimeoutMillis;

  /**
   * Equivalent to ``aFunc``, but retries upon transient failure.
   *
   * Retrying is done through an exponential backoff algorithm configured
   * by the options in ``retry``.
   * @param {Object} argument The request object.
   * @param {APICallback} callback The callback.
   * @return {function()} cancel function.
   */
  return function retryingFunc(argument, callback) {
    var canceller;
    var timeoutId;
    var now = new Date();
    var deadline;
    if (retry.backoffSettings.totalTimeoutMillis) {
      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;
    }
    var retries = 0;
    var maxRetries = retry.backoffSettings.maxRetries;

    /** Repeat the API call as long as necessary. */
    function repeat() {
      timeoutId = null;
      if (deadline &amp;&amp; now.getTime() >= deadline) {
        callback(new Error('Retry total timeout exceeded before any' +
            'response was received'));
        return;
      }

      if (retries &amp;&amp; retries >= maxRetries) {
        callback(new Error('Exceeded maximum number of retries before any ' +
            'response was received'));
        return;
      }

      retries++;
      var toCall = addTimeoutArg(aFunc, timeout, otherArgs);
      canceller = toCall(argument, function(err) {
        if (!err) {
          var args = Array.prototype.slice.call(arguments, 1);
          args.unshift(null);
          callback.apply(null, args);
          return;
        }
        canceller = null;
        if (retry.retryCodes.indexOf(err.code) &lt; 0) {
          err.note = 'Exception occurred in retry method that was ' +
              'not classified as transient';
          callback(err);
        } else {
          var toSleep = Math.random() * delay;
          timeoutId = setTimeout(function() {
            now = new Date();
            delay = Math.min(delay * delayMult, maxDelay);
            timeout = Math.min(timeout * timeoutMult, maxTimeout,
                                          deadline - now.getTime());
            repeat();
          }, toSleep);
        }
      });
    }

    if (maxRetries &amp;&amp; deadline) {
      callback(new Error('Cannot set both totalTimeoutMillis and maxRetries ' +
          'in backoffSettings.'));
    } else {
      repeat();
    }

    return {
      cancel: function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (canceller) {
          canceller.cancel();
        } else {
          callback(new Error('cancelled'));
        }
      }
    };
  };
}

/**
 * Creates an API caller for normal methods.
 *
 * @private
 * @constructor
 */
function NormalApiCaller() {
}

NormalApiCaller.prototype.init = function(settings, callback) {
  return new PromiseCanceller(callback);
};

NormalApiCaller.prototype.wrap = function(func) {
  return func;
};

NormalApiCaller.prototype.call = function(
    apiCall, argument, settings, canceller) {
  canceller.call(apiCall, argument);
};

NormalApiCaller.prototype.fail = function(canceller, err) {
  canceller.reject(err);
};

NormalApiCaller.prototype.result = function(canceller) {
  return canceller.promise;
};

exports.NormalApiCaller = NormalApiCaller;

/**
 * Converts an rpc call into an API call governed by the settings.
 *
 * In typical usage, `func` will be a promsie to a callable used to make an rpc
 * request. This will mostly likely be a bound method from a request stub used
 * to make an rpc call. It is not a direct function but a Promise instance,
 * because of its asynchronism (typically, obtaining the auth information).
 *
 * The result is a function which manages the API call with the given settings
 * and the options on the invocation.
 *
 * @param {Promise.&lt;APIFunc>} funcWithAuth - is a promise to be used to make
 *   a bare rpc call. This is a Promise instead of a bare function because
 *   the rpc call will be involeved with asynchronous authentications.
 * @param {CallSettings} settings - provides the settings for this call
 * @param {Object=} optDescriptor - optionally specify the descriptor for
 *   the method call.
 * @return {APICall} func - a bound method on a request stub used
 *   to make an rpc call.
 * @throws - if `settings` has incompatible values, e.g, if bundling
 *   and page_streaming are both configured.
 */
exports.createApiCall = function createApiCall(
    funcWithAuth, settings, optDescriptor) {
  var apiCaller =
      optDescriptor ? optDescriptor.apiCaller(settings) : new NormalApiCaller();

  return function apiCallInner(request, callOptions, callback) {
    var thisSettings = settings.merge(callOptions);

    var status = apiCaller.init(thisSettings, callback);
    funcWithAuth.then(function(func) {
      func = apiCaller.wrap(func);
      if (thisSettings.retry &amp;&amp; thisSettings.retry.retryCodes) {
        return retryable(func, thisSettings.retry, thisSettings.otherArgs);
      }
      return addTimeoutArg(func, thisSettings.timeout, thisSettings.otherArgs);
    }).then(function(apiCall) {
      apiCaller.call(apiCall, request, thisSettings, status);
    }).catch(function(err) {
      // setTimeout is necessary to raise an error outside of the promise.
      // Otherwise the error won't be thrown to the outer environment but
      // used for rejecting the promise itself.
      setTimeout(function() {
        apiCaller.fail(status, err);
      }, 0);
    });
    return apiCaller.result(status);
  };
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BundleDescriptor.html">BundleDescriptor</a></li><li><a href="BundleExecutor.html">BundleExecutor</a></li><li><a href="CallSettings.html">CallSettings</a></li><li><a href="GrpcClient.html">GrpcClient</a></li><li><a href="OperationsApi.html">OperationsApi</a></li><li><a href="PageDescriptor.html">PageDescriptor</a></li><li><a href="PathTemplate.html">PathTemplate</a></li><li><a href="StreamDescriptor.html">StreamDescriptor</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ALL_SCOPES">ALL_SCOPES</a></li><li><a href="global.html#computeBundleId">computeBundleId</a></li><li><a href="global.html#constructSettings">constructSettings</a></li><li><a href="global.html#createApiCall">createApiCall</a></li><li><a href="global.html#createBackoffSettings">createBackoffSettings</a></li><li><a href="global.html#createCredPromise">createCredPromise</a></li><li><a href="global.html#createMaxRetriesBackoffSettings">createMaxRetriesBackoffSettings</a></li><li><a href="global.html#createRetryOptions">createRetryOptions</a></li><li><a href="global.html#formatSegments">formatSegments</a></li><li><a href="global.html#operationsApi">operationsApi</a></li><li><a href="global.html#StreamType">StreamType</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Nov 18 2016 10:30:07 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
